#ifndef EGRAPHABLE_H
#define EGRAPHABLE_H

#include<vector>

template <typename HeuristicType>
class EGraphable{
  public:

    //This is a domain specific function (and is not always possible). This is especially important if the choice of
    //heuristic is a down-projection from the original state space (for instance the heuristic guides a subset of 
    //the state varibles, like 2D grid search heuristic from the goal for an x,y,heading navigation problem.
    //In these cases, the E-Graph heuristic will guide the search to down-projections of experience and 
    //therefore, the search will have no guidance when trying to align the remaining state variables (for example
    //in the 2D heuristic for x,y,heading navigation the heuristic will guide the robot to have the same xy coordinate
    //as some state in the prior experience but then will struggle to align the heading). 
    //
    //To combat this, the planner will detect these scenarios and call this function to generate a "snap motion". 
    //Snap motions try to directly connect two states (one off the experience graph to one on it). 
    //If it is possible for your environment to directly connect an arbitrary (though nearby) pair of states
    //and you have a heuristic which only considers a subset of the state variables, you should implement this.
    //
    //"from" and "to" are the coordinates of the two states
    //if successful, you should fill in "id" with the id number of the "to" state, fill in "cost" with the 
    //cost of the motion, and return true
    //if the motion failed, return false ("id" and "cost" are irrelevant then)
    virtual bool snap(const std::vector<double>& from, const std::vector<double>& to, int& id, int& cost){return false;};

    //This function takes a state id and the environment should fill in the coordinate (vector of doubles) for 
    //the corresponding state. We promise to never call getCoord on the goal state (because it is possible
    //that the goal is underspecified and you may not know what the goal state will be).
    //This function returns true if the id actually exists and you were able to provide a coordinate.
    //It returns false if you could not. This should NEVER happen. The E-Graph planner should only call getCoord
    //on IDs which you already provided to us from getStateID or GetLazySuccsWithUniqueIds. 
    //
    //**This function MUST be the inverse of getStateID**
    //Use TestEGraphable if you want to confirm this.
    virtual bool getCoord(int id, std::vector<double>& coord) = 0;

    //This function takes a state vector and returns a state ID for it. Often, the coordinate we give you will
    //be one you have seen before and you should just be able to look up its ID. However, sometimes we will 
    //give you a coordinate you have never seen before. This generally should only happen when loading an E-Graph
    //from file or from a demonstration where a path was not generated by the planner itself.
    //This function must ALWAYS succeed. If you don't have a state ID for this coordinate yet you have to make one. 
    //
    //**This function MUST be the inverse of getCoord**
    //Use TestEGraphable if you want to confirm this.
    virtual int getStateID(const std::vector<double>& coord) = 0;

    //This take a state ID and returns if its corresponding state meets the goal conditions
    virtual bool isGoal(int id) = 0;

    //This function is called if the user tells the planner that the environment has changed. In that case
    //the planner will validate all edges and vertices in the experience graph. This function provides two states
    //"coord" and "coord2" you must check if edges connecting them is still valid (return true if so and false if not). 
    //If the edge is still valid, you can tell the E-Graph that the cost of the edge has changed "change_cost" and 
    //then if you set that to true, you should fill in "cost". If you set "change_cost" to false, the E-Graph will 
    //continue to use the previous edge cost.
    //If your environment is static (you know that edge costs will never change) you can just set change_cost to false
    //and always return true.
    virtual bool isValidEdge(const std::vector<double>& coord, const std::vector<double>& coord2, bool& change_cost, int& cost) = 0;

    //This function is called if the user tells the planner that the environment has changed. In that case
    //the planner will validate all edges and vertices in the experience graph. This function provides a state 
    //coordinate and you return whether the state is still valid. If your environment is static you can just 
    //return true.
    virtual bool isValidVertex(const std::vector<double>& coord) = 0;

    //This function converts a state coordinate to a "heuristic coordinate". This depends on what heuristic you are
    //using. For instance, for euclidean distance heuristic, the heuristic coordinate is exactly the same as the 
    //state coordinate and "HeuristicType" would be a vector of doubles (you can see that the whole EGraphable
    //class is templated on the heuristic type). In the case of a 2D grid search heuristic for an x,y,heading
    //domain, the HeuristicType would be a vector of ints and the continuous x,y from the state would be
    //converted to discrete indices into the 2D grid.
    virtual void projectToHeuristicSpace(const std::vector<double>& coord, HeuristicType& heur_coord) const = 0;

    //Refer to the comment on projectToHeuristicSpace
    //The only difference is that this function returns the coordinate specifically for the goal. 
    //The reason we can't use the other function for the goal is that the goal might not be fully
    //specified and therefore we can't assume we have a coordinate to give you for the goal state.
    virtual void projectGoalToHeuristicSpace(HeuristicType& heur_coord) const = 0;

};

#endif
